# üê¶ Nitter Scraper V2 - Documentation Compl√®te

## üìã Vue d'ensemble

Nitter Scraper V2 est un package TypeScript puissant permettant de r√©cup√©rer des tweets depuis Nitter sans authentification. Cette version am√©lior√©e ajoute le support des proxies, l'extraction de m√©dias (images/vid√©os), les cartes de pr√©visualisation, les informations de v√©rification des comptes, les statistiques des tweets, le mode concurrent et bien plus encore !

## ‚ú® Fonctionnalit√©s principales

- üöÄ **Scraping sans authentification** - Aucune cl√© API Twitter n√©cessaire
- üîÑ **Gestion automatique de la pagination** - R√©cup√®re plusieurs pages automatiquement
- üõ°Ô∏è **Protection contre la limitation de d√©bit** - D√©lais intelligents entre les requ√™tes
- üåê **Support proxy avanc√©** - Trois modes : sans proxy, liste personnalis√©e, ou URL de t√©l√©chargement
- üì∑ **Extraction de m√©dias** - Images, vid√©os avec informations d√©taill√©es et cartes de pr√©visualisation
- üë§ **Informations utilisateur compl√®tes** - Avatar, nom complet, statut et type de v√©rification
- üìä **Statistiques des tweets** - Commentaires, retweets, citations, likes, vues
- ‚ö° **Mode concurrent** - R√©cup√©ration s√©quentielle rapide sans d√©lais
- üîß **TypeScript natif** - Typages complets et intellisense
- ‚ö° **Performance optimis√©e** - Gestion d'erreurs et retry automatique

## üì¶ Installation

### Installation comme biblioth√®que
```bash
npm install nitter-scraper-v2
```

### Installation globale pour utilisation CLI
```bash
npm install -g nitter-scraper-v2
```

### Avec Bun (recommand√© pour le d√©veloppement)
```bash
bun install nitter-scraper-v2
```

## üöÄ D√©marrage rapide

### Utilisation basique

```typescript
import { fetchTweets } from "nitter-scraper-v2";

async function main() {
  const tweets = await fetchTweets("elonmusk", 3);
  console.log(`Trouv√© ${tweets.length} tweets`);

  tweets.forEach((tweet) => {
    // Informations de base avec nom complet
    console.log(`${tweet.fullname} (@${tweet.username}): ${tweet.text}`);
    
    // Informations de v√©rification
    if (tweet.isVerified) {
      console.log(`‚úÖ V√©rifi√© (${tweet.verificationType})`);
    }
    
    // Statistiques d'engagement
    console.log(`üìä ${tweet.stats.likes} likes, ${tweet.stats.retweets} retweets, ${tweet.stats.comments} commentaires`);
    
    // M√©dias
    if (tweet.imageTweet.length > 0) {
      console.log(`üì∑ Images: ${tweet.imageTweet.length}`);
    }
    if (tweet.videos.length > 0) {
      console.log(`üé• Vid√©os: ${tweet.videos.length}`);
      tweet.videos.forEach(video => {
        console.log(`  - Vid√©o: ${video.videoUrl}`);
        console.log(`  - Miniature: ${video.posterUrl}`);
      });
    }
  });
}

main().catch(console.error);
```

### Mode concurrent pour un scraping rapide

```typescript
import { fetchTweets } from "nitter-scraper-v2";

async function scrapingRapide() {
  // Mode concurrent : supprime les d√©lais entre les requ√™tes
  const tweets = await fetchTweets(
    "username", 
    5,           // maxPages
    false,       // useProxies
    undefined,   // proxyOptions
    true         // useConcurrency - NOUVEAU !
  );
  
  console.log(`R√©cup√©r√© ${tweets.length} tweets rapidement !`);
}
```

### Utilisation comme outil CLI

```bash
# Lancer le scraper avec Bun
bun run cli

# Ou si install√© globalement
nitter-scraper-v2
```

## üìö API compl√®te

### Fonction fetchTweets (mise √† jour)

```typescript
function fetchTweets(
  username: string,
  maxPages?: number,
  useProxies?: boolean,
  proxyOptions?: ProxyOptions,
  useConcurrency?: boolean  // NOUVEAU !
): Promise<Tweet[]>;
```

#### Param√®tres

| Param√®tre       | Type           | D√©faut       | Description                                            |
| --------------- | -------------- | ------------ | ------------------------------------------------------ |
| `username`      | `string`       | **requis**   | Nom d'utilisateur Twitter (sans @)                    |
| `maxPages`      | `number`       | `3`          | Nombre maximum de pages √† r√©cup√©rer                   |
| `useProxies`    | `boolean`      | `false`      | Activer l'utilisation de proxies                      |
| `proxyOptions`  | `ProxyOptions` | `undefined`  | Options de configuration des proxies                  |
| `useConcurrency`| `boolean`      | `false`      | **NOUVEAU !** Mode s√©quentiel rapide (sans d√©lais)   |

## üåê Gestion des proxies

Cette version offre trois modes de gestion des proxies :

### 1. Sans proxy (par d√©faut)

```typescript
const tweets = await fetchTweets("username", 3, false);
```

### 2. Liste de proxies personnalis√©e

```typescript
import { fetchTweets, ProxyOptions } from "nitter-scraper-v2";

const proxyOptions: ProxyOptions = {
  proxyList: [
    "192.168.1.1:8080:user1:pass1",
    "192.168.1.2:8080:user2:pass2",
    "192.168.1.3:8080:user3:pass3",
  ],
};

const tweets = await fetchTweets("username", 3, true, proxyOptions);
```

### 3. URL de t√©l√©chargement de proxies

```typescript
const proxyOptions: ProxyOptions = {
  proxyUrl: "https://votre-serveur.com/proxies.txt",
};

const tweets = await fetchTweets("username", 3, true, proxyOptions);
```

## üìù Types TypeScript (mis √† jour)

### Interface Tweet (compl√®te)

```typescript
interface Tweet {
  id: string;                    // ID unique du tweet
  text: string;                  // Contenu textuel du tweet
  username: string;              // Nom d'utilisateur de l'auteur
  fullname: string;              // NOUVEAU ! Nom complet de l'auteur
  isVerified: boolean;           // NOUVEAU ! Statut de v√©rification
  verificationType: string | null; // NOUVEAU ! Type de v√©rification
  created_at: string;            // Date de cr√©ation (cha√Æne ISO)
  timestamp: number | null;      // Timestamp Unix (millisecondes)
  imageTweet: string[];          // URLs des images attach√©es
  videoTweet: string[];          // URLs des vid√©os attach√©es (legacy)
  videos: VideoInfo[];           // NOUVEAU ! Informations d√©taill√©es des vid√©os
  stats: TweetStats;             // NOUVEAU ! Statistiques du tweet
  avatarUrl: string | null;      // URL de l'avatar utilisateur
  cards: Card[];                 // Cartes de pr√©visualisation
  originalUrl: string;           // URL originale du tweet sur Twitter/X
}
```

### Interface TweetStats (NOUVELLE !)

```typescript
interface TweetStats {
  comments: number;  // Nombre de commentaires
  retweets: number;  // Nombre de retweets
  quotes: number;    // Nombre de citations
  likes: number;     // Nombre de likes
  views: number;     // Nombre de vues
}
```

### Interface VideoInfo (NOUVELLE !)

```typescript
interface VideoInfo {
  posterUrl: string | null;  // URL de la miniature/poster de la vid√©o
  videoUrl: string | null;   // URL du fichier vid√©o
}
```

### Interface ProxyOptions

```typescript
export type ProxyOptions = {
  proxyList?: string[];  // Liste de proxies au format "host:port:username:password"
  proxyUrl?: string;     // URL pour t√©l√©charger la liste de proxies
};
```

### Interface Card

```typescript
interface Card {
  type: "card";              // Type de carte
  url: string | null;        // URL de destination
  imageUrl: string | null;   // URL de l'image de pr√©visualisation
  title: string;             // Titre de la carte
  description: string;       // Description de la carte
  destination: string;       // Domaine de destination
}
```

## üîß Configuration avanc√©e

### Mode concurrent vs Mode s√©quentiel

```typescript
// Mode s√©quentiel (par d√©faut) - d√©lais de 2 secondes entre les requ√™tes
const tweetsSequentiel = await fetchTweets("username", 5, false, undefined, false);

// Mode concurrent - pas de d√©lais, r√©cup√©ration plus rapide
const tweetsConcurrent = await fetchTweets("username", 5, false, undefined, true);
```

**Note importante** : Le mode concurrent ne r√©cup√®re pas les pages en parall√®le (impossible √† cause de la pagination bas√©e sur les curseurs), mais supprime les d√©lais entre les requ√™tes s√©quentielles pour une performance globale plus rapide.

### Format des proxies

Les proxies doivent √™tre au format : `host:port:username:password`

Exemple :
```
proxy1.example.com:8080:monuser:monpass
192.168.1.100:3128:admin:secret123
proxy-server.net:1080:client:password
```

## üìÅ Structure du projet

```
nitter-scraper-v2/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts          # Point d'entr√©e principal
‚îÇ   ‚îú‚îÄ‚îÄ scraper.ts        # Logique de scraping principale
‚îÇ   ‚îú‚îÄ‚îÄ utils/            # Utilitaires
‚îÇ   ‚îî‚îÄ‚îÄ types/            # D√©finitions de types
‚îú‚îÄ‚îÄ dist/                 # Code compil√©
‚îú‚îÄ‚îÄ examples/             # Exemples d'utilisation
‚îú‚îÄ‚îÄ package.json          # Configuration du package
‚îî‚îÄ‚îÄ README.md            # Documentation principale
```

## üí° Exemples d'utilisation avanc√©s

### Analyse compl√®te d'un compte

```typescript
import { fetchTweets } from "nitter-scraper-v2";

async function analyserCompte(username: string) {
  const tweets = await fetchTweets(username, 5, false, undefined, true);
  
  if (tweets.length === 0) {
    console.log("Aucun tweet trouv√©");
    return;
  }
  
  const premierTweet = tweets[0];
  
  // Informations du compte
  console.log(`=== ANALYSE DU COMPTE ===`);
  console.log(`Nom: ${premierTweet.fullname}`);
  console.log(`Username: @${premierTweet.username}`);
  console.log(`V√©rifi√©: ${premierTweet.isVerified ? `Oui (${premierTweet.verificationType})` : 'Non'}`);
  console.log(`Avatar: ${premierTweet.avatarUrl}`);
  
  // Statistiques d'engagement
  const totalLikes = tweets.reduce((sum, tweet) => sum + tweet.stats.likes, 0);
  const totalRetweets = tweets.reduce((sum, tweet) => sum + tweet.stats.retweets, 0);
  const totalComments = tweets.reduce((sum, tweet) => sum + tweet.stats.comments, 0);
  const totalViews = tweets.reduce((sum, tweet) => sum + tweet.stats.views, 0);
  
  console.log(`\n=== STATISTIQUES D'ENGAGEMENT ===`);
  console.log(`Total likes: ${totalLikes} (moyenne: ${Math.round(totalLikes / tweets.length)})`);
  console.log(`Total retweets: ${totalRetweets} (moyenne: ${Math.round(totalRetweets / tweets.length)})`);
  console.log(`Total commentaires: ${totalComments} (moyenne: ${Math.round(totalComments / tweets.length)})`);
  console.log(`Total vues: ${totalViews} (moyenne: ${Math.round(totalViews / tweets.length)})`);
  
  // Analyse des m√©dias
  const tweetsAvecImages = tweets.filter(t => t.imageTweet.length > 0);
  const tweetsAvecVideos = tweets.filter(t => t.videos.length > 0);
  const tweetsAvecCartes = tweets.filter(t => t.cards.length > 0);
  
  console.log(`\n=== UTILISATION DES M√âDIAS ===`);
  console.log(`Tweets avec images: ${tweetsAvecImages.length}/${tweets.length} (${Math.round(tweetsAvecImages.length / tweets.length * 100)}%)`);
  console.log(`Tweets avec vid√©os: ${tweetsAvecVideos.length}/${tweets.length} (${Math.round(tweetsAvecVideos.length / tweets.length * 100)}%)`);
  console.log(`Tweets avec cartes: ${tweetsAvecCartes.length}/${tweets.length} (${Math.round(tweetsAvecCartes.length / tweets.length * 100)}%)`);
  
  // Tweet le plus populaire
  const tweetPopulaire = tweets.reduce((max, tweet) => 
    (tweet.stats.likes + tweet.stats.retweets) > (max.stats.likes + max.stats.retweets) ? tweet : max
  );
  
  console.log(`\n=== TWEET LE PLUS POPULAIRE ===`);
  console.log(`"${tweetPopulaire.text.substring(0, 100)}..."`);
  console.log(`${tweetPopulaire.stats.likes} likes, ${tweetPopulaire.stats.retweets} retweets`);
}
```

### Comparaison de performance des modes

```typescript
async function comparerPerformance(username: string, pages: number = 3) {
  console.log(`üîÑ Comparaison de performance pour ${pages} pages`);
  
  // Test mode s√©quentiel
  console.log("\nüìä Test du mode s√©quentiel...");
  const debutSequentiel = Date.now();
  const tweetsSequentiel = await fetchTweets(username, pages, false, undefined, false);
  const tempsSequentiel = Date.now() - debutSequentiel;
  
  // Test mode concurrent
  console.log("‚ö° Test du mode concurrent...");
  const debutConcurrent = Date.now();
  const tweetsConcurrent = await fetchTweets(username, pages, false, undefined, true);
  const tempsConcurrent = Date.now() - debutConcurrent;
  
  // R√©sultats
  console.log(`\nüìà R√âSULTATS:`);
  console.log(`Mode s√©quentiel: ${tweetsSequentiel.length} tweets en ${tempsSequentiel}ms`);
  console.log(`Mode concurrent: ${tweetsConcurrent.length} tweets en ${tempsConcurrent}ms`);
  console.log(`Am√©lioration: ${Math.round((tempsSequentiel / tempsConcurrent - 1) * 100)}% plus rapide`);
  console.log(`Gain de temps: ${tempsSequentiel - tempsConcurrent}ms`);
}
```

### Extraction et analyse des vid√©os

```typescript
async function analyserVideos(username: string) {
  const tweets = await fetchTweets(username, 10, false, undefined, true);
  
  const tweetsAvecVideos = tweets.filter(tweet => tweet.videos.length > 0);
  
  console.log(`üé• Analyse des vid√©os pour @${username}`);
  console.log(`Tweets avec vid√©os: ${tweetsAvecVideos.length}/${tweets.length}`);
  
  if (tweetsAvecVideos.length === 0) {
    console.log("Aucune vid√©o trouv√©e");
    return;
  }
  
  let totalVideos = 0;
  let videosAvecPoster = 0;
  let videosAvecUrl = 0;
  
  tweetsAvecVideos.forEach((tweet, index) => {
    console.log(`\nüìù Tweet ${index + 1}:`);
    console.log(`"${tweet.text.substring(0, 80)}..."`);
    console.log(`Engagement: ${tweet.stats.likes} likes, ${tweet.stats.views} vues`);
    
    tweet.videos.forEach((video, videoIndex) => {
      totalVideos++;
      console.log(`  üé¨ Vid√©o ${videoIndex + 1}:`);
      
      if (video.videoUrl) {
        videosAvecUrl++;
        console.log(`    - URL vid√©o: ${video.videoUrl}`);
      }
      
      if (video.posterUrl) {
        videosAvecPoster++;
        console.log(`    - Miniature: ${video.posterUrl}`);
      }
    });
  });
  
  console.log(`\nüìä Statistiques des vid√©os:`);
  console.log(`Total vid√©os: ${totalVideos}`);
  console.log(`Vid√©os avec URL: ${videosAvecUrl}/${totalVideos}`);
  console.log(`Vid√©os avec miniature: ${videosAvecPoster}/${totalVideos}`);
}
```

### Filtrage avanc√© par type de v√©rification

```typescript
async function analyserVerification(username: string) {
  const tweets = await fetchTweets(username, 5, false, undefined, true);
  
  if (tweets.length === 0) return;
  
  const compte = tweets[0];
  
  console.log(`üîç Analyse de v√©rification pour @${username}`);
  console.log(`Nom complet: ${compte.fullname}`);
  console.log(`Statut: ${compte.isVerified ? 'V√©rifi√©' : 'Non v√©rifi√©'}`);
  
  if (compte.isVerified) {
    switch (compte.verificationType) {
      case 'business':
        console.log(`‚úÖ Compte Business - Entreprise ou organisation v√©rifi√©e`);
        break;
      case 'blue':
        console.log(`üîµ Twitter Blue - Abonnement payant v√©rifi√©`);
        break;
      case 'verified':
        console.log(`‚≠ê Compte V√©rifi√© - Personnalit√© publique authentifi√©e`);
        break;
      default:
        console.log(`‚ùì Type de v√©rification inconnu: ${compte.verificationType}`);
    }
  }
  
  // Analyser l'engagement selon le type de v√©rification
  const engagementMoyen = tweets.reduce((sum, t) => 
    sum + t.stats.likes + t.stats.retweets + t.stats.comments, 0
  ) / tweets.length;
  
  console.log(`üìä Engagement moyen: ${Math.round(engagementMoyen)} interactions par tweet`);
}
```

### Export complet en JSON

```typescript
import * as fs from "fs";

async function exporterAnalyseComplete(username: string, filename: string) {
  console.log(`üì• Export complet pour @${username}...`);
  
  const tweets = await fetchTweets(username, 10, false, undefined, true);
  
  if (tweets.length === 0) {
    console.log("Aucun tweet √† exporter");
    return;
  }
  
  const compte = tweets[0];
  
  // Calculer les statistiques
  const stats = {
    totalTweets: tweets.length,
    totalLikes: tweets.reduce((sum, t) => sum + t.stats.likes, 0),
    totalRetweets: tweets.reduce((sum, t) => sum + t.stats.retweets, 0),
    totalComments: tweets.reduce((sum, t) => sum + t.stats.comments, 0),
    totalViews: tweets.reduce((sum, t) => sum + t.stats.views, 0),
    tweetsAvecImages: tweets.filter(t => t.imageTweet.length > 0).length,
    tweetsAvecVideos: tweets.filter(t => t.videos.length > 0).length,
    tweetsAvecCartes: tweets.filter(t => t.cards.length > 0).length,
    totalImages: tweets.reduce((sum, t) => sum + t.imageTweet.length, 0),
    totalVideos: tweets.reduce((sum, t) => sum + t.videos.length, 0),
  };
  
  const donneesExport = {
    metadonnees: {
      username,
      exporteA: new Date().toISOString(),
      version: "nitter-scraper-v2",
    },
    compte: {
      nomComplet: compte.fullname,
      username: compte.username,
      estVerifie: compte.isVerified,
      typeVerification: compte.verificationType,
      urlAvatar: compte.avatarUrl,
    },
    statistiques: {
      ...stats,
      engagementMoyen: Math.round((stats.totalLikes + stats.totalRetweets + stats.totalComments) / stats.totalTweets),
      likesParTweet: Math.round(stats.totalLikes / stats.totalTweets),
      retweetsParTweet: Math.round(stats.totalRetweets / stats.totalTweets),
      commentairesParTweet: Math.round(stats.totalComments / stats.totalTweets),
      vuesParTweet: Math.round(stats.totalViews / stats.totalTweets),
    },
    tweets: tweets.map(tweet => ({
      ...tweet,
      // Ajouter des m√©triques calcul√©es
      engagementTotal: tweet.stats.likes + tweet.stats.retweets + tweet.stats.comments,
      tauxEngagement: tweet.stats.views > 0 ? 
        Math.round((tweet.stats.likes + tweet.stats.retweets + tweet.stats.comments) / tweet.stats.views * 100) : 0,
    })),
  };
  
  fs.writeFileSync(filename, JSON.stringify(donneesExport, null, 2));
  console.log(`‚úÖ Export termin√©: ${filename}`);
  console.log(`üìä ${stats.totalTweets} tweets, ${stats.totalImages} images, ${stats.totalVideos} vid√©os`);
}

// Utilisation
exporterAnalyseComplete("elonmusk", "analyse_elonmusk.json");
```

## ‚ö° Conseils de performance

### Recommandations par cas d'usage

1. **Scraping rapide (1-5 pages)** : Utilisez le mode concurrent
   ```typescript
   const tweets = await fetchTweets("username", 3, false, undefined, true);
   ```

2. **Scraping intensif (10+ pages)** : Utilisez des proxies avec mode concurrent
   ```typescript
   const tweets = await fetchTweets("username", 15, true, proxyOptions, true);
   ```

3. **Analyse en temps r√©el** : Mode s√©quentiel avec d√©lais pour √©viter les blocages
   ```typescript
   const tweets = await fetchTweets("username", 2, false, undefined, false);
   ```

### Comparaison de performance

| Cas d'usage | Mode | Pages | Temps estim√© | Recommandation |
|-------------|------|-------|--------------|----------------|
| Test rapide | Concurrent | 3 | ~3s | ‚úÖ Optimal |
| Analyse standard | Concurrent | 5 | ~5s | ‚úÖ Optimal |
| Scraping intensif | Concurrent + Proxy | 10 | ~8s | ‚úÖ Optimal |
| Surveillance continue | S√©quentiel | 2 | ~6s | ‚úÖ Plus s√ªr |

## üö® Limitations et bonnes pratiques

### Nouvelles limitations

- **Mode concurrent** : Plus rapide mais plus risqu√© de d√©tection
- **Statistiques** : D√©pendent de la structure HTML de Nitter
- **Vid√©os** : La d√©tection peut varier selon le format des tweets
- **V√©rification** : Les types peuvent √©voluer avec les changements de Twitter/X

### Bonnes pratiques mises √† jour

1. **Utilisez le mode concurrent avec mod√©ration**
   ```typescript
   // ‚úÖ Bon pour des tests rapides
   const tweets = await fetchTweets("username", 3, false, undefined, true);
   
   // ‚ùå √âvitez pour de gros volumes sans proxies
   const tweets = await fetchTweets("username", 20, false, undefined, true);
   ```

2. **V√©rifiez les donn√©es extraites**
   ```typescript
   tweets.forEach(tweet => {
     if (tweet.stats.likes === 0 && tweet.stats.retweets === 0) {
       console.warn("Statistiques possiblement manquantes pour:", tweet.id);
     }
   });
   ```

3. **G√©rez les cas d'erreur pour les nouvelles fonctionnalit√©s**
   ```typescript
   tweets.forEach(tweet => {
     // V√©rification s√©curis√©e
     const verification = tweet.isVerified ? 
       `V√©rifi√© (${tweet.verificationType || 'type inconnu'})` : 
       'Non v√©rifi√©';
     
     // Statistiques avec valeurs par d√©faut
     const stats = {
       likes: tweet.stats?.likes || 0,
       retweets: tweet.stats?.retweets || 0,
       // ...
     };
   });
   ```

## üîç D√©pannage des nouvelles fonctionnalit√©s

### Probl√®mes courants

1. **Statistiques √† z√©ro** : Structure HTML modifi√©e
2. **Vid√©os non d√©tect√©es** : Nouveau format de conteneur
3. **Type de v√©rification null** : Nouveau type non reconnu
4. **Mode concurrent bloqu√©** : Trop de requ√™tes rapides

### Solutions

```typescript
// Diagnostic des statistiques
function diagnostiquerStats(tweets: Tweet[]) {
  const statsVides = tweets.filter(t => 
    t.stats.likes === 0 && t.stats.retweets === 0 && t.stats.comments === 0
  );
  
  if (statsVides.length > tweets.length * 0.5) {
    console.warn("‚ö†Ô∏è  Plus de 50% des tweets ont des statistiques vides");
    console.warn("Possible changement de structure HTML de Nitter");
  }
}

// Test de d√©tection des vid√©os
function testerDetectionVideos(tweets: Tweet[]) {
  const videosLegacy = tweets.reduce((sum, t) => sum + t.videoTweet.length, 0);
  const videosNouvelles = tweets.reduce((sum, t) => sum + t.videos.length, 0);
  
  console.log(`Vid√©os d√©tect√©es - Legacy: ${videosLegacy}, Nouvelles: ${videosNouvelles}`);
  
  if (videosLegacy > videosNouvelles) {
    console.warn("‚ö†Ô∏è  L'ancienne m√©thode d√©tecte plus de vid√©os");
  }
}
```

## üìÑ Licence

Ce projet est sous licence MIT. Voir le fichier LICENSE pour plus de d√©tails.

## ü§ù Contribution

Les contributions sont les bienvenues ! N'h√©sitez pas √† ouvrir des issues ou soumettre des pull requests pour :

- Am√©liorer la d√©tection des vid√©os
- Ajouter de nouveaux types de v√©rification
- Optimiser les performances du mode concurrent
- Corriger les bugs de parsing des statistiques

---

*Documentation mise √† jour pour nitter-scraper-v2 avec les nouvelles fonctionnalit√©s : informations de v√©rification, mode concurrent, statistiques des tweets et extraction d√©taill√©e des vid√©os.* 